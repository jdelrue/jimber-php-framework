=Jimber PHP Framework=
==Using Jimber PHP Framework==
===Template engine===
The template engine is used to seperate HTML and PHP code. It's short, simple and solid. A template file contains only html and looks as follows:
{{{
 <!-- BEGIN TITLEBLOCK -->
 <h1> {{TITLE}} </h1>
 <!-- END TITLEBLOCK -->

 <!-- BEGIN CONTENTBLOCK -->
 <p> {{CONTENT}} </p>
 <!-- END CONTENTBLOCK -->
}}}

There are 5 functions to know about:
{{{
 Template(file)
}}}
The constructor. Make a new template from a template file.
{{{
 AddFile(file)
}}}
Add another file to the template.
{{{
 DefineBlock(blockname)
}}}
Define a block that exists within the template.
{{{
 setVars(blockname,varname,value)
}}}
Set a var in a template block. Plural because all instances of the var are replaced.
{{{
 ParseBlock(blockname)
}}}
Parse a block to html. Returns the html.
{{{
 Show(blockname)
}}}
Will echo the block. Echo works fine but this is more controlled and adjustable.

Some interesting things:

* Blocks can be concatenated 
 (block1->ParseBlock(blockname).block2->ParseBlock(blockname2)
* Blocks can be set as vars for other blocks,
 (block1->setVars(blockname, varname,block2->ParseBlock(blockname2))

====Example====

Say there is a file page.html containing the html code
{{{
 <!-- BEGIN DIVEXAMPLE -->
  <div class="example"> <p> Lorem ipsum something {{VAR}} </p></div>
 <!-- END DIVEXAMPLE -->

 <!-- BEGIN PAGEBLOCK -->
 <!doctype html>
 <html lang="en">
     <head>
         <meta charset="utf-8" />
         <title>Some title</title>
    
     </head>
     <body>
          <p> some text </p>
          {{MORECONTENT}}
     </body>
 </html>

 <!-- END PAGEBLOCK -->
}}}

Then it is possible to build the PHP file like this

{{{
<?
require_once("lib/SmartLibs.php");

libadd("lib.Jimber");
libadd("lib.Jimber.Data.MySQL");

$tpl = new Template("testing/templates/desktop.tpl");
$tpl->DefineBlock("PAGEBLOCK");
$tpl->DefineBlock("DIVEXAMPLE");
$tpl->setVars("DIVEXAMPLE", "VAR", "and something else");
$tpl->setVars("PAGEBLOCK", "MORECONTENT", $tpl->parseBlock("DIVEXAMPLE"));
$html = $tpl->ParseBlock("DESKTOP");
$tpl->Show($html);

?>
}}}

===Entity generator===

The entity generator will generate a very simple entity class for each table in the database. This class will extend the abstract Entity class which will provide the most functions. Currently only support for MySQL is provided. Support for other databases like PostgreSQL can easily be added.

The entity generator consists of following files:
* Fetcher.php: Fetches the database structure
* Generator.php: Generates the entity classes
* Entity.php: Provides functionality

To use the entity generator simply surf to Fetcher.php. The only requirement is that the Data directory is writeable by the webserver. 

This is an example of a generated entity, from the user table in a database:
{{{
 class User extends Entity {
     var $ID;
     var $name;
     var $pass;
     var $email;
     var $contactID;
     var $primaryKeys = array("ID");
    var $auto_increment = array("ID");
 function getClass() { return __CLASS__; }
 }
}}}

===Datagrids===
Forms and grids with Jimber are easy and efficient. Forms in Jimer are used to present, modify or insert data in the database. To use Forms or Grids, it's important to first understand the fields system.

====Fields====
{{{
 $fields = Array();
 
 // Define fields for form
 
 $fields[0] = new Field("Textbox", "name", "Company Name");
 $fields[0]->validator = "^[a-z -']+$";
 $fields[1] = new Field("Textbox", "address", "Address");
 $fields[2] = new Field("Textbox","email", "E-mail");
 $fields[3] = new Field("Textbox", "tel", "Tel.");
 $fields[4] = new Field("Textbox", "zip", "ZIP/Postcode");
 $fields[5] = new Field("Select", "countryID", "Country");
 $fields[5]->collection = Country::Select();
 $fields[5]->textfield = "printable_name";
 
 $form = new Form($fields, "", true,true);
 $form->type = "Company";
 
 $htm = $form->BuildStandardForm(); // returns html code
}}}
This is an example of a database driven form (default) with 5 fields. Let's analyze the first field as an example.
{{{
 $fields[0] = new Field("Textbox", "name", "Company Name");
}}}
The Field constructor is as follows:
{{{
  function field($type, $dbname, $showname, $disabled = false);
}}}
The type of the field (Text, Textbox, Select, Wiki, ...) determines how the field will be represented in HTML code and how the data will be handled upon submitting ,more information on this in the "Elements" section. Besides this the constructor needs the name, which is a column in the database, a representing name, shown on the page, and a flag wether to disable the element. In this case a textbox is generated, data binded to the "name" column in the Company database.

Another, more complex example is the fifth field:
{{{
 $fields[5] = new Field("Select", "countryID", "Country");
 $fields[5]->collection = Country::Select();
 $fields[5]->textfield = "printable_name";
}}}
This field is a HTML select box. The collection in the select box is gathered from the Select method of the Country column. The textfield represents the name of the column of this collection. So in the select box all "printable_names" of each Country will be seen. This code is about the same:
{{{
 $fields[5] = new SelectField("Select", "countryID", "Country");
 $fields[5]->collection = Country::Select();
 $fields[5]->textfield = "printable_name";
}}}
The result is the same, but when coding intellisense will show the options that are usable for SelectField.

====Showing the grid====

Besides the fields the type is set for insert forms (default) and after this the HTML code can be generated using the BuildStandardForm method.
{{{
 BuildStandardForm($addPageNavigator = false);
}}}
A page navigator should not be added for this simple form. False is default.

====A typical datagrid====

Say we want a datagrid of all our customers. It could be built up as follows.
{{{

 $col = Contact::Select();
 $contactFields = Array();
 $contactFields[0] = new Field("Text", "name", "Name");
 $contactFields[1] = new Field("Text", "address", "Address");
 $contactFields[2] = new Field("Text", "email", "E-Mail");
 $contactFields[3] = new Field("Text", "companyID:name", "Company");
 $contactFields[4] = new Field("URL", "ID", "Edit");
 $contactFields[4]->preURL = "contact_details.php?pb=" . Encrypt("contact_mng.php") . "&amp;contact=";

 $contactgrid = new Grid($contactFields, $col, false);
 $contactgrid->sorting = true;
 if (isset($_GET['page'])) {
    $contactgrid->page = $_GET['page'];
 }
 $existinghtm = $contactgrid->BuildStandardGrid(true);

}}}

This will make a grid containing all contacts, showing information that is non editable. The first fields are trivial but the last one is an URL. The preURL option will put something in front of the URL. In this case the column will have the word "Edit' and link to the preURL string, concatenated with the ID.

Also, sorting is enabled. This makes column headers clickable, sorting also works accross pages. The page is set from the page variable posted to the page. The grid will change this page value by default, other pagevars can also be used. The last line builds the HTML code of the grid, including the pagenavigator (true).

====Possible elements in DataGrids====
At this moment following field types can be used:

 * Checkbox
 * Date
 * Datebox
 * Delete
 * Hidden
 * Image
 * LinkedText
 * SQLBox
 * Select
 * Text
 * Textarea
 * TextboxPassword
 * TextboxSuggest
 * Textpre
 * URL
 * Upload
 * WikiText*



===Tools===